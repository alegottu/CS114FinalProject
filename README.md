Proof of concept for using an octree to quickly calculate appropriate LODs for models in a scene; currently, only one model is loaded in the scene, but you can add more by following the example at line 413 of [main.cpp](https://github.com/alegottu/CS114FinalProject/blob/master/src/main.cpp) - each LOD for a model is loaded using `loadModel`, and each model will be an inner array, containing each level of detail for that model, within the array `models`.

The current example only uses two levels of detail, where the algorithm for finding the LOD for each object (found in [Octree.h](https://github.com/alegottu/CS114FinalProject/blob/master/include/Octree.h) at function `findLevelsOfDetail`) simply sets the LOD of any objects found in the same octant as the camera to the highest LOD (0, or the first element in the array for that model), and the rest of the objects in other octants to a worse LOD (1). In the future, this would be the main part of the project to improve, where models in the octant diagonal from the camera's octant on 3 axes would be the lowest level of detail, models in the octants diagonal from the camera's octant on 2 axes would be one level of detail higher, models in the laterally or vertically adjacent octants to the camera would be one more level of detail higher, and finally models in the same octant as the camera would remain at the highest level of detail. If the scene is particularly large, you could perform this same process with several octrees for different areas of the scene, allowing for even more levels of detail.

One weakness of how the project currently works is that models' level of detail change immediately while they are still in view, so ideally the difference between adjacent levels of detail would be hardly noticable, or another improvement could be to queue changes in detail to happen only once each model queued to change is in a position far and away from the camera's view, or otherwise using some combination of distance and direction from the camera as criteria in addition to which octant a model is found in.

Although the project is only supposed to be a fun take on an LOD algorithm, another weakness caused naturally by using an octree in this manner for distinguishing LODs is that there are some unnatural points of transition for each LOD; especially when the camera is close to a border between two or more octants, LODs can change too many times in a short period, or while certain models are still close to the camera, since a pure distance is not being used to calculate each LOD. However, more in the spirit of how octrees are often used for collision detection, if the algorithm were to be improved instead by using the camera's frustrum as a collision shape, then calculating LODs by using different versions of that frustrum, each with different lengths to represent a different percieved area by the camera, then if an octree were already being used to ignore models out of view, this process could combine nicely with that.

Note: built using Visual Studio
